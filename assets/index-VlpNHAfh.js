var R = Object.defineProperty; var j = (e, t, n) => t in e ? R(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n; var E = (e, t, n) => (j(e, typeof t != "symbol" ? t + "" : t, n), n); (function () { const t = document.createElement("link").relList; if (t && t.supports && t.supports("modulepreload")) return; for (const l of document.querySelectorAll('link[rel="modulepreload"]')) i(l); new MutationObserver(l => { for (const a of l) if (a.type === "childList") for (const o of a.addedNodes) o.tagName === "LINK" && o.rel === "modulepreload" && i(o) }).observe(document, { childList: !0, subtree: !0 }); function n(l) { const a = {}; return l.integrity && (a.integrity = l.integrity), l.referrerPolicy && (a.referrerPolicy = l.referrerPolicy), l.crossOrigin === "use-credentials" ? a.credentials = "include" : l.crossOrigin === "anonymous" ? a.credentials = "omit" : a.credentials = "same-origin", a } function i(l) { if (l.ep) return; l.ep = !0; const a = n(l); fetch(l.href, a) } })(); function p() { } function S(e) { return e() } function I() { return Object.create(null) } function w(e) { e.forEach(S) } function C(e) { return typeof e == "function" } function T(e, t) { return e != e ? t == t : e !== t || e && typeof e == "object" || typeof e == "function" } function D(e) { return Object.keys(e).length === 0 } function H(e, t, n) { e.insertBefore(t, n || null) } function L(e) { e.parentNode && e.parentNode.removeChild(e) } function z(e) { return document.createElement(e) } function q(e) { return Array.from(e.childNodes) } let y; function b(e) { y = e } function K() { if (!y) throw new Error("Function called outside component initialization"); return y } function Q(e) { K().$$.on_mount.push(e) } const m = [], O = []; let h = []; const P = [], U = Promise.resolve(); let B = !1; function V() { B || (B = !0, U.then(A)) } function F(e) { h.push(e) } const N = new Set; let f = 0; function A() { if (f !== 0) return; const e = y; do { try { for (; f < m.length;) { const t = m[f]; f++, b(t), W(t.$$) } } catch (t) { throw m.length = 0, f = 0, t } for (b(null), m.length = 0, f = 0; O.length;)O.pop()(); for (let t = 0; t < h.length; t += 1) { const n = h[t]; N.has(n) || (N.add(n), n()) } h.length = 0 } while (m.length); for (; P.length;)P.pop()(); B = !1, N.clear(), b(e) } function W(e) { if (e.fragment !== null) { e.update(), w(e.before_update); const t = e.dirty; e.dirty = [-1], e.fragment && e.fragment.p(e.ctx, t), e.after_update.forEach(F) } } function G(e) { const t = [], n = []; h.forEach(i => e.indexOf(i) === -1 ? t.push(i) : n.push(i)), n.forEach(i => i()), h = t } const J = new Set; function X(e, t) { e && e.i && (J.delete(e), e.i(t)) } function Y(e, t, n) { const { fragment: i, after_update: l } = e.$$; i && i.m(t, n), F(() => { const a = e.$$.on_mount.map(S).filter(C); e.$$.on_destroy ? e.$$.on_destroy.push(...a) : w(a), e.$$.on_mount = [] }), l.forEach(F) } function Z(e, t) { const n = e.$$; n.fragment !== null && (G(n.after_update), w(n.on_destroy), n.fragment && n.fragment.d(t), n.on_destroy = n.fragment = null, n.ctx = []) } function ee(e, t) { e.$$.dirty[0] === -1 && (m.push(e), V(), e.$$.dirty.fill(0)), e.$$.dirty[t / 31 | 0] |= 1 << t % 31 } function te(e, t, n, i, l, a, o = null, g = [-1]) { const c = y; b(e); const r = e.$$ = { fragment: null, ctx: [], props: a, update: p, not_equal: l, bound: I(), on_mount: [], on_destroy: [], on_disconnect: [], before_update: [], after_update: [], context: new Map(t.context || (c ? c.$$.context : [])), callbacks: I(), dirty: g, skip_bound: !1, root: t.target || c.$$.root }; o && o(r.root); let v = !1; if (r.ctx = n ? n(e, t.props || {}, (u, _, ...d) => { const $ = d.length ? d[0] : _; return r.ctx && l(r.ctx[u], r.ctx[u] = $) && (!r.skip_bound && r.bound[u] && r.bound[u]($), v && ee(e, u)), _ }) : [], r.update(), v = !0, w(r.before_update), r.fragment = i ? i(r.ctx) : !1, t.target) { if (t.hydrate) { const u = q(t.target); r.fragment && r.fragment.l(u), u.forEach(L) } else r.fragment && r.fragment.c(); t.intro && X(e.$$.fragment), Y(e, t.target, t.anchor), A() } b(c) } class ne { constructor() { E(this, "$$"); E(this, "$$set") } $destroy() { Z(this, 1), this.$destroy = p } $on(t, n) { if (!C(n)) return p; const i = this.$$.callbacks[t] || (this.$$.callbacks[t] = []); return i.push(n), () => { const l = i.indexOf(n); l !== -1 && i.splice(l, 1) } } $set(t) { this.$$set && !D(t) && (this.$$.skip_bound = !0, this.$$set(t), this.$$.skip_bound = !1) } } const ie = "4"; typeof window < "u" && (window.__svelte || (window.__svelte = { v: new Set })).v.add(ie); function le(e) {
        let t; return {
                c() {
                        t = z("main"), t.innerHTML = `<div class="head"><h1>HRN Calculator</h1> <div class="desc">A Tool to Calculate Profit, Fees, and Debts for <a href="https://www.copytradingwithhrn.com/">HRN Copy Trading Service</a></div></div> <div class="container"><div class="inputData"><div class="item"><label for="init">Initial Balance account</label> <input value="0" type="number" id="init"/> $</div> <div class="item"><label for="final">Final Balance</label> <input value="0" type="number" id="final"/> $</div> <div class="item"><label for="take-from-acc">Take Next Month&#39;s Fee from Account?</label> <input type="checkbox" id="take-from-acc"/></div> <div class="item"><button id="reset"><span class="material-symbols-outlined">autorenew</span> <d>Reset</d></button></div></div> <div class="output"><div class="item"><label for="fee">Starting 7% fee</label> <input value="0" type="text" id="fee" readonly=""/> $</div> <div class="item"><label for="profit-each">Profit</label> <input value="0" type="number" id="profit" readonly=""/> $</div> <div class="item"><label for="profit-each">Profit for each</label> <input value="0" type="number" id="profit-each" readonly=""/> $</div> <div class="item"><label for="debt">Debt</label> <input value="0" type="number" id="debt" readonly=""/> $
        <p>hint: negative number means Client should pay the debt</p></div> <div class="item"><label for="next-init">Next month&#39;s Starting Balance</label> <input value="0" type="number" id="next-init" readonly=""/> $</div> <div class="item"><label for="next-fee">Next month&#39;s 7% fee</label> <input value="0" type="number" id="next-fee" readonly=""/> $</div> <div class="item"><label for="next-real-fee">Next month&#39;s Net fee (realized with debt)</label> <input value="0" type="number" id="next-real-fee" readonly=""/> $</div> <div class="item"><label for="withdrawal">Withdrawal</label> <input value="0" type="number" id="withdrawal" readonly=""/> $</div></div></div>`}, m(n, i) { H(n, t, i) }, p, i: p, o: p, d(n) { n && L(t) }
        }
} function re(e) { return Q(() => { const t = document.getElementById("init"), n = document.getElementById("fee"), i = document.getElementById("final"), l = document.getElementById("profit"), a = document.getElementById("profit-each"), o = document.getElementById("debt"), g = document.getElementById("take-from-acc"), c = document.getElementById("next-init"), r = document.getElementById("next-fee"), v = document.getElementById("next-real-fee"), u = document.getElementById("withdrawal"), _ = document.getElementById("reset"), d = .07, $ = .06542; function x() { let k = Number(i.value) - Number(t.value); if (l.value = k, a.value = (k / 2).toFixed(1), n.value = (Number(t.value) * d).toFixed(1), o.value = (n.value - a.value).toFixed(1), g.checked) { let s = Number(i.value) + Number(o.value); s = Number(s - s * $).toFixed(1); let M = Math.abs(Number(i.value) - s); c.value = s, r.value = (s * d).toFixed(1), v.value = (Number(r.value) - Number(o.value)).toFixed(1), u.value = Number(M).toFixed(1) } else c.value = i.value, r.value = (Number(i.value) * d).toFixed(1), v.value = (Number(r.value) - Number(o.value)).toFixed(1), u.value = 0 } t.onkeyup = x, i.onkeyup = x, g.onchange = x, _.onclick = () => { t.value = 0, i.value = 0, x() } }), [] } class ae extends ne { constructor(t) { super(), te(this, t, re, le, T, {}) } } new ae({ target: document.getElementById("app") });
